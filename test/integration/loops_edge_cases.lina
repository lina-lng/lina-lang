(* Test while and for loop edge cases *)

(* Test 1: For loop where start > end (zero iterations) *)
let test_empty_to =
  let count = ref 0 in
  for i = 10 to 5 do
    count := !count + 1
  done;
  print (!count)
(* Expected: 0 *)

(* Test 2: For downto where start < end (zero iterations) *)
let test_empty_downto =
  let count = ref 0 in
  for i = 5 downto 10 do
    count := !count + 1
  done;
  print (!count)
(* Expected: 0 *)

(* Test 3: For loop i = 0 to 0 (single iteration) *)
let test_single_to =
  let count = ref 0 in
  for i = 0 to 0 do
    count := !count + 1
  done;
  print (!count)
(* Expected: 1 *)

(* Test 4: For loop i = 5 downto 5 (single iteration) *)
let test_single_downto =
  let count = ref 0 in
  for i = 5 downto 5 do
    count := !count + 1
  done;
  print (!count)
(* Expected: 1 *)

(* Test 5: While loop that never executes *)
let test_while_never =
  let count = ref 0 in
  while false do
    count := !count + 1
  done;
  print (!count)
(* Expected: 0 *)

(* Test 6: Empty loop body *)
let test_empty_body =
  for i = 1 to 3 do
    ()
  done;
  print "empty body ok"
(* Expected: empty body ok *)

(* Test 7: Nested loops (3 levels) *)
let test_nested =
  let count = ref 0 in
  for i = 1 to 2 do
    for j = 1 to 3 do
      for k = 1 to 4 do
        count := !count + 1
      done
    done
  done;
  print (!count)
(* Expected: 24 *)

(* Test 8: Loop variable shadowing outer variable *)
let test_shadow =
  let i = 999 in
  let sum = ref 0 in
  for i = 1 to 3 do
    sum := !sum + i
  done;
  print (!sum);
  print i
(* Expected: 6 *)
(* Expected: 999 *)

(* Test 9: Loop bounds with complex expressions *)
let test_complex_bounds =
  let start = 2 + 3 in
  let finish = 10 - 2 in
  let sum = ref 0 in
  for i = start to finish do
    sum := !sum + i
  done;
  print (!sum)
(* Expected: 26 *)

(* Test 10: Loop bounds evaluated once *)
(* Note: Using top-level counter to avoid sequence-in-local-function issue *)
let bounds_counter = ref 0
let get_bound _ =
  bounds_counter := !bounds_counter + 1;
  3

let test_bounds_once =
  for i = 1 to get_bound () do
    ()
  done;
  print (!bounds_counter)
(* Expected: 1 *)

(* Test 11: Accumulator patterns *)
let test_accumulator =
  let sum = ref 0 in
  let product = ref 1 in
  for i = 1 to 5 do
    sum := !sum + i;
    product := !product * i
  done;
  print (!sum);
  print (!product)
(* Expected: 15 *)
(* Expected: 120 *)

(* Test 12: While with multiple conditions *)
let test_while_multi =
  let x = ref 0 in
  let y = ref 10 in
  while !x < 5 do
    x := !x + 1;
    y := !y - 1
  done;
  print (!x);
  print (!y)
(* Expected: 5 *)
(* Expected: 5 *)

(* Test 13: For loop with negative range *)
let test_negative =
  let sum = ref 0 in
  for i = 0 - 3 to 0 - 1 do
    sum := !sum + i
  done;
  print (!sum)
(* Expected: -6 *)

(* Test 14: Downto with accumulator *)
let test_downto_acc =
  let result = ref "" in
  for i = 3 downto 1 do
    result := !result ^ (if i == 3 then "3" else if i == 2 then "2" else "1")
  done;
  print (!result)
(* Expected: 321 *)

(* Test 15: While loop breaking early pattern *)
let test_early_break =
  let found = ref false in
  let target = 7 in
  let i = ref 0 in
  while not (!found) do
    i := !i + 1;
    if !i == target then found := true else ()
  done;
  print (!i)
(* Expected: 7 *)

let _ = print "Loop edge cases complete"
