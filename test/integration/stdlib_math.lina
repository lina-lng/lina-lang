(* Comprehensive integration tests for Math stdlib module *)

(* Helper for approximate float equality *)
let approx_eq a b epsilon =
  let diff = if a > b then a -. b else b -. a in
  diff < epsilon

let assert_approx msg a b =
  if approx_eq a b 0.0001 then
    print ("OK: " ^ msg)
  else
    let _ = print ("FAIL: " ^ msg) in
    let _ = print a in
    print b

let assert_true msg cond =
  if cond then print ("OK: " ^ msg)
  else print ("FAIL: " ^ msg)

let assert_eq_int msg a b =
  if a = b then print ("OK: " ^ msg)
  else
    let _ = print ("FAIL: " ^ msg) in
    let _ = print a in
    print b

(* ===================================================================== *)
(* SECTION 1: CONSTANTS                                                  *)
(* ===================================================================== *)

let test_constants () =
  let _ = print "=== Section 1: Constants ===" in
  let _ = assert_approx "pi ~= 3.14159" Math.pi 3.14159 in
  let _ = assert_true "pi > 3.14 and pi < 3.15" (Math.pi > 3.14 && Math.pi < 3.15) in
  let _ = assert_true "huge is very large" (Math.huge > 1000000000.0) in
  assert_true "huge + 1 = huge (infinity behavior)" (Math.huge +. 1.0 = Math.huge)

let _ = test_constants ()

(* ===================================================================== *)
(* SECTION 2: ROUNDING FUNCTIONS                                         *)
(* ===================================================================== *)

let test_floor () =
  let _ = print "--- floor ---" in
  let _ = assert_approx "floor 3.0 = 3" (Math.floor 3.0) 3.0 in
  let _ = assert_approx "floor 3.1 = 3" (Math.floor 3.1) 3.0 in
  let _ = assert_approx "floor 3.5 = 3" (Math.floor 3.5) 3.0 in
  let _ = assert_approx "floor 3.9 = 3" (Math.floor 3.9) 3.0 in
  let _ = assert_approx "floor -3.0 = -3" (Math.floor (-3.0)) (-3.0) in
  let _ = assert_approx "floor -3.1 = -4" (Math.floor (-3.1)) (-4.0) in
  let _ = assert_approx "floor -3.5 = -4" (Math.floor (-3.5)) (-4.0) in
  let _ = assert_approx "floor -3.9 = -4" (Math.floor (-3.9)) (-4.0) in
  let _ = assert_approx "floor 0.0 = 0" (Math.floor 0.0) 0.0 in
  let _ = assert_approx "floor 0.5 = 0" (Math.floor 0.5) 0.0 in
  assert_approx "floor -0.5 = -1" (Math.floor (-0.5)) (-1.0)

let test_ceil () =
  let _ = print "--- ceil ---" in
  let _ = assert_approx "ceil 3.0 = 3" (Math.ceil 3.0) 3.0 in
  let _ = assert_approx "ceil 3.1 = 4" (Math.ceil 3.1) 4.0 in
  let _ = assert_approx "ceil 3.5 = 4" (Math.ceil 3.5) 4.0 in
  let _ = assert_approx "ceil 3.9 = 4" (Math.ceil 3.9) 4.0 in
  let _ = assert_approx "ceil -3.0 = -3" (Math.ceil (-3.0)) (-3.0) in
  let _ = assert_approx "ceil -3.1 = -3" (Math.ceil (-3.1)) (-3.0) in
  let _ = assert_approx "ceil -3.5 = -3" (Math.ceil (-3.5)) (-3.0) in
  let _ = assert_approx "ceil -3.9 = -3" (Math.ceil (-3.9)) (-3.0) in
  let _ = assert_approx "ceil 0.0 = 0" (Math.ceil 0.0) 0.0 in
  let _ = assert_approx "ceil 0.1 = 1" (Math.ceil 0.1) 1.0 in
  assert_approx "ceil -0.1 = 0" (Math.ceil (-0.1)) 0.0

let test_round () =
  let _ = print "--- round ---" in
  let _ = assert_approx "round 3.4 = 3" (Math.round 3.4) 3.0 in
  let _ = assert_approx "round 3.5 = 4" (Math.round 3.5) 4.0 in
  let _ = assert_approx "round 3.6 = 4" (Math.round 3.6) 4.0 in
  let _ = assert_approx "round -3.4 = -3" (Math.round (-3.4)) (-3.0) in
  let _ = assert_approx "round -3.5 = -4" (Math.round (-3.5)) (-4.0) in
  let _ = assert_approx "round -3.6 = -4" (Math.round (-3.6)) (-4.0) in
  let _ = assert_approx "round 0.4 = 0" (Math.round 0.4) 0.0 in
  let _ = assert_approx "round 0.5 = 1" (Math.round 0.5) 1.0 in
  let _ = assert_approx "round -0.4 = 0" (Math.round (-0.4)) 0.0 in
  assert_approx "round -0.5 = -1" (Math.round (-0.5)) (-1.0)

let test_trunc () =
  let _ = print "--- trunc ---" in
  let _ = assert_approx "trunc 3.9 = 3" (Math.trunc 3.9) 3.0 in
  let _ = assert_approx "trunc 3.1 = 3" (Math.trunc 3.1) 3.0 in
  let _ = assert_approx "trunc -3.9 = -3" (Math.trunc (-3.9)) (-3.0) in
  let _ = assert_approx "trunc -3.1 = -3" (Math.trunc (-3.1)) (-3.0) in
  let _ = assert_approx "trunc 0.9 = 0" (Math.trunc 0.9) 0.0 in
  assert_approx "trunc -0.9 = 0" (Math.trunc (-0.9)) 0.0

let test_rounding_identities () =
  let _ = print "--- rounding identities ---" in
  let _ = assert_true "floor x <= x for positive" (Math.floor 3.7 <= 3.7) in
  let _ = assert_true "floor x <= x for negative" (Math.floor (-3.7) <= (-3.7)) in
  let _ = assert_true "ceil x >= x for positive" (Math.ceil 3.2 >= 3.2) in
  let _ = assert_true "ceil x >= x for negative" (Math.ceil (-3.2) >= (-3.2)) in
  let _ = assert_true "trunc(x) between 0 and x for positive" (Math.trunc 3.9 >= 0.0 && Math.trunc 3.9 <= 3.9) in
  assert_true "trunc(x) between x and 0 for negative" (Math.trunc (-3.9) <= 0.0 && Math.trunc (-3.9) >= (-3.9))

let _ = print "=== Section 2: Rounding Functions ==="
let _ = test_floor ()
let _ = test_ceil ()
let _ = test_round ()
let _ = test_trunc ()
let _ = test_rounding_identities ()

(* ===================================================================== *)
(* SECTION 3: ABSOLUTE VALUE                                             *)
(* ===================================================================== *)

let test_abs () =
  let _ = print "=== Section 3: Absolute Value ===" in
  let _ = assert_approx "abs 5.5 = 5.5" (Math.abs 5.5) 5.5 in
  let _ = assert_approx "abs -5.5 = 5.5" (Math.abs (-5.5)) 5.5 in
  let _ = assert_approx "abs 0.0 = 0.0" (Math.abs 0.0) 0.0 in
  let _ = assert_approx "abs tiny = tiny" (Math.abs 0.000001) 0.000001 in
  let _ = assert_approx "abs -tiny = tiny" (Math.abs (-0.000001)) 0.000001 in
  let _ = assert_eq_int "abs_int 42 = 42" (Math.abs_int 42) 42 in
  let _ = assert_eq_int "abs_int -42 = 42" (Math.abs_int (-42)) 42 in
  let _ = assert_eq_int "abs_int 0 = 0" (Math.abs_int 0) 0 in
  let _ = assert_true "abs(x) >= 0 always" (Math.abs (-123.456) >= 0.0) in
  assert_true "abs_int(x) >= 0 always" (Math.abs_int (-123) >= 0)

let _ = test_abs ()

(* ===================================================================== *)
(* SECTION 4: MIN/MAX                                                    *)
(* ===================================================================== *)

let test_min_max () =
  let _ = print "=== Section 4: Min/Max ===" in
  let _ = assert_approx "min 3.0 5.0 = 3.0" (Math.min 3.0 5.0) 3.0 in
  let _ = assert_approx "min 5.0 3.0 = 3.0" (Math.min 5.0 3.0) 3.0 in
  let _ = assert_approx "min 3.0 3.0 = 3.0" (Math.min 3.0 3.0) 3.0 in
  let _ = assert_approx "min -3.0 3.0 = -3.0" (Math.min (-3.0) 3.0) (-3.0) in
  let _ = assert_approx "max 3.0 5.0 = 5.0" (Math.max 3.0 5.0) 5.0 in
  let _ = assert_approx "max 5.0 3.0 = 5.0" (Math.max 5.0 3.0) 5.0 in
  let _ = assert_approx "max -3.0 3.0 = 3.0" (Math.max (-3.0) 3.0) 3.0 in
  let _ = assert_eq_int "min_int 3 5 = 3" (Math.min_int 3 5) 3 in
  let _ = assert_eq_int "min_int -3 3 = -3" (Math.min_int (-3) 3) (-3) in
  let _ = assert_eq_int "max_int 3 5 = 5" (Math.max_int 3 5) 5 in
  let _ = assert_eq_int "max_int -3 3 = 3" (Math.max_int (-3) 3) 3 in
  let _ = assert_true "min(a,b) <= max(a,b)" (Math.min 3.0 5.0 <= Math.max 3.0 5.0) in
  let _ = assert_true "min(a,b) <= a" (Math.min 3.0 5.0 <= 3.0) in
  assert_true "max(a,b) >= b" (Math.max 3.0 5.0 >= 5.0)

let _ = test_min_max ()

(* ===================================================================== *)
(* SECTION 5: FMOD AND MODF                                              *)
(* ===================================================================== *)

let test_fmod () =
  let _ = print "=== Section 5: Fmod and Modf ===" in
  let _ = assert_approx "fmod 10.0 3.0 = 1.0" (Math.fmod 10.0 3.0) 1.0 in
  let _ = assert_approx "fmod 10.5 3.0 = 1.5" (Math.fmod 10.5 3.0) 1.5 in
  let _ = assert_approx "fmod 9.0 3.0 = 0.0" (Math.fmod 9.0 3.0) 0.0 in
  let _ = assert_approx "fmod -10.0 3.0 = -1.0" (Math.fmod (-10.0) 3.0) (-1.0) in
  ()

let test_modf () =
  let _ = print "--- modf ---" in
  let (int_part1, frac_part1) = Math.modf 3.75 in
  let _ = assert_approx "modf 3.75 int_part = 3" int_part1 3.0 in
  let _ = assert_approx "modf 3.75 frac_part = 0.75" frac_part1 0.75 in
  let (int_part2, frac_part2) = Math.modf (-3.75) in
  let _ = assert_approx "modf -3.75 int_part = -3" int_part2 (-3.0) in
  let _ = assert_approx "modf -3.75 frac_part = -0.75" frac_part2 (-0.75) in
  let (int_part3, frac_part3) = Math.modf 5.0 in
  let _ = assert_approx "modf 5.0 int_part = 5" int_part3 5.0 in
  let _ = assert_approx "modf 5.0 frac_part = 0" frac_part3 0.0 in
  (* modf identity: int_part + frac_part = x *)
  let test_identity x =
    let (int_part, frac_part) = Math.modf x in
    approx_eq (int_part +. frac_part) x 0.0001
  in
  let _ = assert_true "modf identity for 3.75" (test_identity 3.75) in
  let _ = assert_true "modf identity for -3.75" (test_identity (-3.75)) in
  assert_true "modf identity for 100.001" (test_identity 100.001)

let _ = test_fmod ()
let _ = test_modf ()

(* ===================================================================== *)
(* SECTION 6: EXPONENTIAL AND LOGARITHMIC                                *)
(* ===================================================================== *)

let test_exp_log () =
  let _ = print "=== Section 6: Exponential and Logarithmic ===" in
  let _ = assert_approx "exp 0 = 1" (Math.exp 0.0) 1.0 in
  let _ = assert_approx "exp 1 ~= e" (Math.exp 1.0) 2.718281828 in
  let _ = assert_approx "exp 2 ~= e^2" (Math.exp 2.0) 7.389056099 in
  let _ = assert_approx "exp -1 ~= 1/e" (Math.exp (-1.0)) 0.367879441 in
  let _ = assert_approx "log 1 = 0" (Math.log 1.0) 0.0 in
  let _ = assert_approx "log e ~= 1" (Math.log 2.718281828) 1.0 in
  let _ = assert_approx "log10 1 = 0" (Math.log10 1.0) 0.0 in
  let _ = assert_approx "log10 10 = 1" (Math.log10 10.0) 1.0 in
  let _ = assert_approx "log10 100 = 2" (Math.log10 100.0) 2.0 in
  let _ = assert_approx "log10 1000 = 3" (Math.log10 1000.0) 3.0 in
  ()

let test_sqrt_pow () =
  let _ = print "--- sqrt and pow ---" in
  let _ = assert_approx "sqrt 0 = 0" (Math.sqrt 0.0) 0.0 in
  let _ = assert_approx "sqrt 1 = 1" (Math.sqrt 1.0) 1.0 in
  let _ = assert_approx "sqrt 4 = 2" (Math.sqrt 4.0) 2.0 in
  let _ = assert_approx "sqrt 9 = 3" (Math.sqrt 9.0) 3.0 in
  let _ = assert_approx "sqrt 16 = 4" (Math.sqrt 16.0) 4.0 in
  let _ = assert_approx "sqrt 2 ~= 1.414" (Math.sqrt 2.0) 1.41421356 in
  let _ = assert_approx "pow 2 0 = 1" (Math.pow 2.0 0.0) 1.0 in
  let _ = assert_approx "pow 2 10 = 1024" (Math.pow 2.0 10.0) 1024.0 in
  let _ = assert_approx "pow 3 3 = 27" (Math.pow 3.0 3.0) 27.0 in
  let _ = assert_approx "pow 2 -1 = 0.5" (Math.pow 2.0 (-1.0)) 0.5 in
  let _ = assert_approx "pow 4 0.5 = 2" (Math.pow 4.0 0.5) 2.0 in
  ()

let test_exp_log_identities () =
  let _ = print "--- exp/log identities ---" in
  let _ = assert_approx "log(exp(x)) = x" (Math.log (Math.exp 3.5)) 3.5 in
  let _ = assert_approx "exp(log(x)) = x" (Math.exp (Math.log 3.5)) 3.5 in
  let _ = assert_approx "sqrt(x) = pow(x, 0.5)" (Math.sqrt 7.0) (Math.pow 7.0 0.5) in
  let _ = assert_approx "pow(x,2) = x*x" (Math.pow 3.5 2.0) (3.5 *. 3.5) in
  assert_approx "log10(10^x) = x" (Math.log10 (Math.pow 10.0 2.5)) 2.5

let _ = test_exp_log ()
let _ = test_sqrt_pow ()
let _ = test_exp_log_identities ()

(* ===================================================================== *)
(* SECTION 7: TRIGONOMETRIC FUNCTIONS                                    *)
(* ===================================================================== *)

let test_sin () =
  let _ = print "=== Section 7: Trigonometric Functions ===" in
  let _ = print "--- sin ---" in
  let _ = assert_approx "sin 0 = 0" (Math.sin 0.0) 0.0 in
  let _ = assert_approx "sin pi/6 = 0.5" (Math.sin (Math.pi /. 6.0)) 0.5 in
  let _ = assert_approx "sin pi/4 ~= 0.707" (Math.sin (Math.pi /. 4.0)) 0.70710678 in
  let _ = assert_approx "sin pi/2 = 1" (Math.sin (Math.pi /. 2.0)) 1.0 in
  let _ = assert_approx "sin pi = 0" (Math.sin Math.pi) 0.0 in
  assert_approx "sin 2pi = 0" (Math.sin (2.0 *. Math.pi)) 0.0

let test_cos () =
  let _ = print "--- cos ---" in
  let _ = assert_approx "cos 0 = 1" (Math.cos 0.0) 1.0 in
  let _ = assert_approx "cos pi/3 = 0.5" (Math.cos (Math.pi /. 3.0)) 0.5 in
  let _ = assert_approx "cos pi/2 = 0" (Math.cos (Math.pi /. 2.0)) 0.0 in
  let _ = assert_approx "cos pi = -1" (Math.cos Math.pi) (-1.0) in
  assert_approx "cos 2pi = 1" (Math.cos (2.0 *. Math.pi)) 1.0

let test_tan () =
  let _ = print "--- tan ---" in
  let _ = assert_approx "tan 0 = 0" (Math.tan 0.0) 0.0 in
  let _ = assert_approx "tan pi/4 = 1" (Math.tan (Math.pi /. 4.0)) 1.0 in
  assert_approx "tan -pi/4 = -1" (Math.tan (0.0 -. Math.pi /. 4.0)) (-1.0)

let test_inverse_trig () =
  let _ = print "--- inverse trig ---" in
  let _ = assert_approx "asin 0 = 0" (Math.asin 0.0) 0.0 in
  let _ = assert_approx "asin 0.5 = pi/6" (Math.asin 0.5) (Math.pi /. 6.0) in
  let _ = assert_approx "asin 1 = pi/2" (Math.asin 1.0) (Math.pi /. 2.0) in
  let _ = assert_approx "acos 1 = 0" (Math.acos 1.0) 0.0 in
  let _ = assert_approx "acos 0.5 = pi/3" (Math.acos 0.5) (Math.pi /. 3.0) in
  let _ = assert_approx "acos 0 = pi/2" (Math.acos 0.0) (Math.pi /. 2.0) in
  let _ = assert_approx "atan 0 = 0" (Math.atan 0.0) 0.0 in
  let _ = assert_approx "atan 1 = pi/4" (Math.atan 1.0) (Math.pi /. 4.0) in
  ()

let test_atan2 () =
  let _ = print "--- atan2 ---" in
  let _ = assert_approx "atan2 0 1 = 0" (Math.atan2 0.0 1.0) 0.0 in
  let _ = assert_approx "atan2 1 1 = pi/4" (Math.atan2 1.0 1.0) (Math.pi /. 4.0) in
  let _ = assert_approx "atan2 1 0 = pi/2" (Math.atan2 1.0 0.0) (Math.pi /. 2.0) in
  let _ = assert_approx "atan2 0 -1 = pi" (Math.atan2 0.0 (-1.0)) Math.pi in
  assert_approx "atan2 -1 0 = -pi/2" (Math.atan2 (-1.0) 0.0) (0.0 -. Math.pi /. 2.0)

let test_trig_identities () =
  let _ = print "--- trig identities ---" in
  (* Pythagorean identity: sin^2(x) + cos^2(x) = 1 *)
  let test_pythagorean x =
    let s = Math.sin x in
    let c = Math.cos x in
    approx_eq (s *. s +. c *. c) 1.0 0.0001
  in
  let _ = assert_true "sin^2 + cos^2 = 1 for x=0" (test_pythagorean 0.0) in
  let _ = assert_true "sin^2 + cos^2 = 1 for x=pi/4" (test_pythagorean (Math.pi /. 4.0)) in
  let _ = assert_true "sin^2 + cos^2 = 1 for x=1.234" (test_pythagorean 1.234) in
  (* tan = sin/cos *)
  let test_tan_identity x =
    let t = Math.tan x in
    let sc = Math.sin x /. Math.cos x in
    approx_eq t sc 0.0001
  in
  let _ = assert_true "tan = sin/cos for x=0.5" (test_tan_identity 0.5) in
  (* Inverse function identities *)
  let _ = assert_approx "asin(sin(0.5)) = 0.5" (Math.asin (Math.sin 0.5)) 0.5 in
  let _ = assert_approx "acos(cos(0.5)) = 0.5" (Math.acos (Math.cos 0.5)) 0.5 in
  (* Symmetry *)
  let _ = assert_approx "sin(-x) = -sin(x)" (Math.sin (-0.7)) (0.0 -. Math.sin 0.7) in
  assert_approx "cos(-x) = cos(x)" (Math.cos (-0.7)) (Math.cos 0.7)

let _ = test_sin ()
let _ = test_cos ()
let _ = test_tan ()
let _ = test_inverse_trig ()
let _ = test_atan2 ()
let _ = test_trig_identities ()

(* ===================================================================== *)
(* SECTION 8: ANGLE CONVERSION                                           *)
(* ===================================================================== *)

let test_angle_conversion () =
  let _ = print "=== Section 8: Angle Conversion ===" in
  let _ = assert_approx "deg 0 = 0" (Math.deg 0.0) 0.0 in
  let _ = assert_true "deg pi ~= 180" (approx_eq (Math.deg Math.pi) 180.0 0.001) in
  let _ = assert_approx "deg pi/2 = 90" (Math.deg (Math.pi /. 2.0)) 90.0 in
  let _ = assert_true "deg 2pi ~= 360" (approx_eq (Math.deg (2.0 *. Math.pi)) 360.0 0.001) in
  let _ = assert_approx "rad 0 = 0" (Math.rad 0.0) 0.0 in
  let _ = assert_approx "rad 180 = pi" (Math.rad 180.0) Math.pi in
  let _ = assert_approx "rad 90 = pi/2" (Math.rad 90.0) (Math.pi /. 2.0) in
  let _ = assert_approx "rad 360 = 2pi" (Math.rad 360.0) (2.0 *. Math.pi) in
  (* Round-trip conversion *)
  let _ = assert_approx "deg(rad(x)) = x" (Math.deg (Math.rad 45.0)) 45.0 in
  assert_approx "rad(deg(x)) = x" (Math.rad (Math.deg 1.0)) 1.0

let _ = test_angle_conversion ()

(* ===================================================================== *)
(* SECTION 9: RANDOM NUMBERS                                             *)
(* ===================================================================== *)

let test_random () =
  let _ = print "=== Section 9: Random Numbers ===" in
  let _ = Math.randomseed 12345 in
  (* Test random() returns values in [0, 1) *)
  let r1 = Math.random () in
  let r2 = Math.random () in
  let r3 = Math.random () in
  let _ = assert_true "random() in [0,1)" (r1 >= 0.0 && r1 < 1.0 && r2 >= 0.0 && r2 < 1.0 && r3 >= 0.0 && r3 < 1.0) in
  (* Test random_int returns values in [1, n] *)
  let ri1 = Math.random_int 10 in
  let ri2 = Math.random_int 10 in
  let _ = assert_true "random_int(10) in [1,10]" (ri1 >= 1 && ri1 <= 10 && ri2 >= 1 && ri2 <= 10) in
  (* Test random_range *)
  let rr1 = Math.random_range 5 15 in
  let rr2 = Math.random_range 5 15 in
  let _ = assert_true "random_range(5,15) in [5,15]" (rr1 >= 5 && rr1 <= 15 && rr2 >= 5 && rr2 <= 15) in
  ()

let test_randomseed () =
  let _ = print "--- randomseed ---" in
  let _ = Math.randomseed 99999 in
  let a1 = Math.random () in
  let a2 = Math.random () in
  let _ = Math.randomseed 99999 in
  let b1 = Math.random () in
  let b2 = Math.random () in
  let _ = assert_approx "same seed gives same sequence (1st)" a1 b1 in
  let _ = assert_approx "same seed gives same sequence (2nd)" a2 b2 in
  (* Different seeds give different sequences *)
  let _ = Math.randomseed 11111 in
  let s1 = Math.random () in
  let _ = Math.randomseed 22222 in
  let s2 = Math.random () in
  assert_true "different seeds give different values" (not (approx_eq s1 s2 0.0001))

let _ = test_random ()
let _ = test_randomseed ()

(* ===================================================================== *)
(* SECTION 10: COMBINED OPERATIONS                                       *)
(* ===================================================================== *)

let test_combined () =
  let _ = print "=== Section 10: Combined Operations ===" in
  let _ = assert_approx "sqrt(pow(3,2)) = 3" (Math.sqrt (Math.pow 3.0 2.0)) 3.0 in
  let _ = assert_approx "pow(sqrt(16),2) = 16" (Math.pow (Math.sqrt 16.0) 2.0) 16.0 in
  let _ = assert_approx "floor(ceil(3.5)) = 4" (Math.floor (Math.ceil 3.5)) 4.0 in
  let _ = assert_approx "ceil(floor(3.5)) = 3" (Math.ceil (Math.floor 3.5)) 3.0 in
  let _ = assert_approx "abs(min(-5,-3)) = 5" (Math.abs (Math.min (-5.0) (-3.0))) 5.0 in
  let _ = assert_approx "sin(rad(30)) = 0.5" (Math.sin (Math.rad 30.0)) 0.5 in
  let _ = assert_approx "cos(rad(60)) = 0.5" (Math.cos (Math.rad 60.0)) 0.5 in
  assert_approx "tan(rad(45)) = 1" (Math.tan (Math.rad 45.0)) 1.0

let _ = test_combined ()

(* ===================================================================== *)
(* SECTION 11: QUADRATIC FORMULA AND DISTANCE                            *)
(* ===================================================================== *)

let test_quadratic () =
  let _ = print "--- quadratic formula ---" in
  let quadratic_formula a b c =
    let discriminant = b *. b -. 4.0 *. a *. c in
    if discriminant < 0.0 then None
    else
      let sqrt_d = Math.sqrt discriminant in
      let x1 = (0.0 -. b +. sqrt_d) /. (2.0 *. a) in
      let x2 = (0.0 -. b -. sqrt_d) /. (2.0 *. a) in
      Some (x1, x2)
  in
  match quadratic_formula 1.0 (-5.0) 6.0 with
  | Some (x1, x2) ->
      let _ = assert_approx "quadratic x^2-5x+6: x1=3" x1 3.0 in
      assert_approx "quadratic x^2-5x+6: x2=2" x2 2.0
  | None -> print "FAIL: quadratic should have solutions"

let test_distance () =
  let _ = print "--- distance formula ---" in
  let distance x1 y1 x2 y2 =
    let dx = x2 -. x1 in
    let dy = y2 -. y1 in
    Math.sqrt (dx *. dx +. dy *. dy)
  in
  let _ = assert_approx "distance (0,0) to (3,4) = 5" (distance 0.0 0.0 3.0 4.0) 5.0 in
  let _ = assert_approx "distance (0,0) to (1,1) = sqrt(2)" (distance 0.0 0.0 1.0 1.0) (Math.sqrt 2.0) in
  assert_approx "distance (1,2) to (4,6) = 5" (distance 1.0 2.0 4.0 6.0) 5.0

let test_polar () =
  let _ = print "--- polar/cartesian conversion ---" in
  let polar_to_cartesian r theta =
    (r *. Math.cos theta, r *. Math.sin theta)
  in
  let (x1, y1) = polar_to_cartesian 1.0 0.0 in
  let _ = assert_approx "polar(1,0) -> x=1" x1 1.0 in
  let _ = assert_approx "polar(1,0) -> y=0" y1 0.0 in
  let (x2, y2) = polar_to_cartesian 1.0 (Math.pi /. 2.0) in
  let _ = assert_approx "polar(1,pi/2) -> x=0" x2 0.0 in
  let _ = assert_approx "polar(1,pi/2) -> y=1" y2 1.0 in
  let cartesian_to_polar x y =
    let r = Math.sqrt (x *. x +. y *. y) in
    let theta = Math.atan2 y x in
    (r, theta)
  in
  let (r3, theta3) = cartesian_to_polar 1.0 0.0 in
  let _ = assert_approx "cartesian(1,0) -> r=1" r3 1.0 in
  assert_approx "cartesian(1,0) -> theta=0" theta3 0.0

let _ = test_quadratic ()
let _ = test_distance ()
let _ = test_polar ()

(* ===================================================================== *)
(* SECTION 12: EDGE CASES AND NUMERICAL ACCURACY                         *)
(* ===================================================================== *)

let test_edge_cases () =
  let _ = print "=== Section 12: Edge Cases ===" in
  (* Zero handling *)
  let _ = assert_approx "sqrt(0) = 0" (Math.sqrt 0.0) 0.0 in
  let _ = assert_approx "pow(0, 5) = 0" (Math.pow 0.0 5.0) 0.0 in
  let _ = assert_approx "pow(5, 0) = 1" (Math.pow 5.0 0.0) 1.0 in
  let _ = assert_approx "sin(0) = 0" (Math.sin 0.0) 0.0 in
  let _ = assert_approx "cos(0) = 1" (Math.cos 0.0) 1.0 in
  let _ = assert_approx "exp(0) = 1" (Math.exp 0.0) 1.0 in
  let _ = assert_approx "log(1) = 0" (Math.log 1.0) 0.0 in
  (* One handling *)
  let _ = assert_approx "sqrt(1) = 1" (Math.sqrt 1.0) 1.0 in
  let _ = assert_approx "pow(1, 100) = 1" (Math.pow 1.0 100.0) 1.0 in
  (* Very small values *)
  let tiny = 0.0000001 in
  let _ = assert_approx "sqrt(tiny^2) = tiny" (Math.sqrt (tiny *. tiny)) tiny in
  let _ = assert_true "sin(tiny) ~= tiny (small angle)" (approx_eq (Math.sin tiny) tiny 0.0001) in
  (* Large values *)
  let large = 1000000.0 in
  let _ = assert_approx "sqrt(large^2) = large" (Math.sqrt (large *. large)) large in
  assert_approx "log10(10^6) = 6" (Math.log10 large) 6.0

let test_numerical_accuracy () =
  let _ = print "--- numerical accuracy ---" in
  let _ = assert_true "pi accurate to 6 decimal places"
    (approx_eq Math.pi 3.14159265358979 0.000001) in
  (* Note: Lua's exp(1) may differ slightly from the mathematical e *)
  let e_val = Math.exp 1.0 in
  let _ = assert_true "e ~= 2.718"
    (approx_eq e_val 2.718281828 0.0001) in
  let sqrt2 = Math.sqrt 2.0 in
  let _ = assert_true "sqrt(2) ~= 1.41421"
    (approx_eq sqrt2 1.41421356 0.00001) in
  let _ = assert_true "sqrt(2)^2 = 2 accurate"
    (approx_eq (sqrt2 *. sqrt2) 2.0 0.0000000001) in
  let test_val = 123.456 in
  let _ = assert_true "exp(log(x)) = x precise"
    (approx_eq (Math.exp (Math.log test_val)) test_val 0.0000001) in
  assert_true "log(exp(x)) = x precise"
    (approx_eq (Math.log (Math.exp 5.5)) 5.5 0.0000001)

let _ = test_edge_cases ()
let _ = test_numerical_accuracy ()

let _ = print "=== All Math tests complete ==="
