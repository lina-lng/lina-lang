(* Test that result type is built-in and works correctly *)

(* Test 1: Basic Ok construction *)
let _ =
  let r = Ok 42 in
  match r with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 42 *)

(* Test 2: Basic Error construction *)
let _ =
  let r = Error "oops" in
  match r with
  | Ok _ -> print "FAIL"
  | Error msg -> print msg
(* Expected: oops *)

(* Test 3: Pattern matching exhaustiveness *)
let handle_result r = match r with
  | Ok x -> x * 2
  | Error _ -> 0

let _ =
  let _ = print (handle_result (Ok 21)) in
  print (handle_result (Error "ignored"))
(* Expected: 42 *)
(* Expected: 0 *)

(* Test 4: Type inference with polymorphism *)
let map_result f r = match r with
  | Ok x -> Ok (f x)
  | Error e -> Error e

let _ =
  let r = map_result (fun x -> x + 1) (Ok 10) in
  match r with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 11 *)

(* Test 5: Different error types *)
let divide a b =
  if b == 0 then Error "division by zero"
  else Ok (a / b)

let _ =
  match divide 10 2 with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 5 *)

let _ =
  match divide 10 0 with
  | Ok _ -> print "FAIL"
  | Error msg -> print msg
(* Expected: division by zero *)

(* Test 6: Nested results *)
let _ =
  let outer = Ok (Ok 100) in
  match outer with
  | Ok inner -> (match inner with
    | Ok n -> print n
    | Error _ -> print "FAIL")
  | Error _ -> print "FAIL"
(* Expected: 100 *)

(* Test 7: Binding operators with built-in result *)
let ( let* ) r f = match r with
  | Ok x -> f x
  | Error e -> Error e

let _ =
  let result =
    let* x = Ok 10 in
    let* y = Ok 20 in
    Ok (x + y)
  in
  match result with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 30 *)

(* Test 8: Error propagation with binding operators *)
let _ =
  let result =
    let* x = Ok 5 in
    let* y = Error "stopped here" in
    let* z = Ok 10 in
    Ok (x + y + z)
  in
  match result with
  | Ok _ -> print "FAIL"
  | Error msg -> print msg
(* Expected: stopped here *)

(* Test 9: Result in function signatures *)
let safe_divide a b =
  if b == 0 then Error "cannot divide by zero"
  else Ok (a / b)

let chain_divide x =
  let* first = safe_divide 100 x in
  let* second = safe_divide first 2 in
  Ok second

let _ =
  match chain_divide 10 with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 5 *)

let _ =
  match chain_divide 0 with
  | Ok _ -> print "FAIL"
  | Error msg -> print msg
(* Expected: cannot divide by zero *)

(* Test 10: Mixing Ok and Error with same type *)
let identity_or_error x =
  if x > 0 then Ok x
  else Error x

let _ =
  match identity_or_error 42 with
  | Ok n -> print n
  | Error _ -> print "FAIL"
(* Expected: 42 *)

let _ =
  match identity_or_error (0 - 7) with
  | Ok _ -> print "FAIL"
  | Error n -> print n
(* Expected: -7 *)

let _ = print "Result built-in tests complete"
(* Expected: Result built-in tests complete *)
