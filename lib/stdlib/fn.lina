(** Function combinators and operators. *)

(** Identity function. *)
let id x = x

(** Constant function - always returns the first argument. *)
let const x _ = x

(** Flip the arguments of a binary function. *)
let flip f x y = f y x

(** Pipe operator: passes a value through a function.
    [x |> f] is equivalent to [f x]. *)
let ( |> ) x f = f x

(** Reverse application: applies a function to a value.
    [f @@ x] is equivalent to [f x]. *)
let ( @@ ) f x = f x

(** Forward composition: [(f >> g) x] is [g (f x)]. *)
let ( >> ) f g x = g (f x)

(** Backward composition: [(f << g) x] is [f (g x)]. *)
let ( << ) f g x = f (g x)

(** Tap: apply a side-effecting function and return the original value. *)
let tap f x =
  let _ = f x in
  x

(** Forward composition: [compose f g x] is [g (f x)].
    Named version of [>>]. *)
let compose f g x = g (f x)

(** Backward composition: [compose_left f g x] is [f (g x)].
    Named version of [<<]. *)
let compose_left f g x = f (g x)

(** Negate a predicate. *)
let negate pred x = if pred x then false else true

(** Apply a function to a value. *)
let apply f x = f x

(** Pipe a value through a function. Named version of [|>]. *)
let pipe x f = f x

(** Ignore a value, returning unit. *)
let ignore _ = ()

(** {1 Currying} *)

(** [curry f] converts a function taking a pair into a curried function.
    [curry f a b] is equivalent to [f (a, b)]. *)
let curry f a b = f (a, b)

(** [uncurry f] converts a curried function into one taking a pair.
    [uncurry f (a, b)] is equivalent to [f a b]. *)
let uncurry f (a, b) = f a b
