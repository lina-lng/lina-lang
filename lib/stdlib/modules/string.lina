(** String manipulation (byte-based, like Lua).

    Lua strings are sequences of bytes. All operations work on bytes,
    not Unicode characters. This matches Lua's native string behavior
    and works on all Lua versions including LuaJIT.

    For ASCII text, bytes and characters are the same. For UTF-8 text,
    be aware that multi-byte characters will be treated as multiple bytes.

    Indices are 1-based (Lua convention) unless otherwise noted. *)

(* FFI declarations must come first *)

@send
external string_len : string -> int = "len"

@val @scope("string")
external string_sub : string -> int -> int -> string = "sub"

@send
external string_upper : string -> string = "upper"

@send
external string_lower : string -> string = "lower"

@val @scope("string")
external string_rep : string -> int -> string = "rep"

@val @scope("string")
external string_byte : string -> int -> int = "byte"

@val @scope("string")
external string_char : int -> string = "char"

@val @scope("string")
external string_gsub_raw : string -> string -> string -> string = "gsub"

@send @return(nullable)
external string_match_raw : string -> string -> string option = "match"

@send @return(nullable)
external string_find_start : string -> string -> int option = "find"

@val @scope("string")
external string_reverse : string -> string = "reverse"

@val @scope("table")
external table_concat : string array -> string -> string = "concat"

(** {1 Basic Operations} *)

(** Return the length of the string in bytes. *)
let length str = string_len str

(** Return [true] if string is empty. *)
let is_empty str = string_len str == 0

(** Get substring from byte index [start] to [stop] (inclusive, 1-based).
    Supports negative indices: -1 is the last byte, -2 is second to last, etc. *)
let sub str start stop = string_sub str start stop

(** Get the byte value at position [index] (1-based), or [None] if out of bounds.
    Returns the numeric byte value (0-255). *)
let get str index =
  if index < 1 || index > string_len str then None
  else Some (string_byte str index)

(** Get the byte value at position [index] (1-based), raising on out of bounds. *)
let get_exn str index =
  if index < 1 || index > string_len str then
    error "String.get_exn: index out of bounds"
  else
    string_byte str index

(** {1 Case Conversion} *)

(** Convert to uppercase (ASCII only). *)
let upper str = string_upper str

(** Convert to lowercase (ASCII only). *)
let lower str = string_lower str

(** Capitalize the first character (ASCII only). *)
let capitalize str =
  if string_len str == 0 then str
  else
    let first = string_upper (string_sub str 1 1) in
    let rest = string_sub str 2 (string_len str) in
    first ^ rest

(** Uncapitalize the first character (ASCII only). *)
let uncapitalize str =
  if string_len str == 0 then str
  else
    let first = string_lower (string_sub str 1 1) in
    let rest = string_sub str 2 (string_len str) in
    first ^ rest

(** {1 Building} *)

(** Repeat string [n] times. Returns empty string if [n <= 0]. *)
let rep str n =
  if n <= 0 then "" else string_rep str n

(** Create a string of [n] copies of byte value [byte]. *)
let make n byte =
  if n <= 0 then ""
  else string_rep (string_char byte) n

(** Join a list of strings with separator. *)
let join sep strings =
  let arr = Array.of_list strings in
  table_concat arr sep

(** Concatenate two strings. *)
let concat str1 str2 = str1 ^ str2

(** Reverse the string (by bytes). *)
let reverse str = string_reverse str

(** {1 Searching} *)

(** Return [true] if [pattern] is found in [str].
    Uses Lua pattern syntax (not regex). *)
let find str pattern =
  Option.is_some (string_find_start str pattern)

(** Return [true] if [str] contains [substring] (literal match, no patterns). *)
let contains str substring =
  let escaped = string_gsub_raw substring "([%^%$%(%)%%%.%[%]%*%+%-%?])" "%%%1" in
  Option.is_some (string_find_start str escaped)

(** Match pattern and return the first match, or [None] if not found.
    Uses Lua pattern syntax. *)
let match_ str pattern = string_match_raw str pattern

(** Global substitution: replace all matches of [pattern] with [replacement].
    Uses Lua pattern syntax. *)
let gsub str pattern replacement = string_gsub_raw str pattern replacement

(** {1 Predicates} *)

(** Return [true] if string starts with [prefix]. *)
let starts_with str prefix =
  let prefix_len = string_len prefix in
  let str_len = string_len str in
  if prefix_len > str_len then false
  else string_sub str 1 prefix_len == prefix

(** Return [true] if string ends with [suffix]. *)
let ends_with str suffix =
  let suffix_len = string_len suffix in
  let str_len = string_len str in
  if suffix_len > str_len then false
  else string_sub str (str_len - suffix_len + 1) str_len == suffix

(** {1 Trimming} *)

(** Remove leading and trailing whitespace. *)
let trim str =
  let trimmed = string_gsub_raw str "^%s+" "" in
  string_gsub_raw trimmed "%s+$" ""

(** Remove leading whitespace. *)
let trim_start str = string_gsub_raw str "^%s+" ""

(** Remove trailing whitespace. *)
let trim_end str = string_gsub_raw str "%s+$" ""

(** {1 Splitting} *)

(** Split string by literal separator.
    Returns list of substrings. Empty separator returns the original string. *)
let split str sep =
  if is_empty str then [str]
  else if is_empty sep then [str]
  else
    let sep_len = string_len sep in
    let str_len = string_len str in
    let escaped_sep = string_gsub_raw sep "([%^%$%(%)%%%.%[%]%*%+%-%?])" "%%%1" in
    let rec go acc pos =
      if pos > str_len then List.reverse acc
      else
        match string_match_raw (string_sub str pos str_len) ("^(.-)" ^ escaped_sep) with
        | None ->
            let remaining = string_sub str pos str_len in
            List.reverse (Cons (remaining, acc))
        | Some part ->
            let new_pos = pos + string_len part + sep_len in
            go (Cons (part, acc)) new_pos
    in
    go Nil 1

(** Split string into lines (by newline character). *)
let lines str = split str "\n"

(** {1 Byte Conversion} *)

(** Convert string to list of byte values (0-255). *)
let to_bytes str =
  let len = string_len str in
  List.init len (fun index -> string_byte str (index + 1))

(** Create string from list of byte values (0-255). *)
let of_bytes bytes =
  List.fold_left (fun acc byte -> acc ^ string_char byte) "" bytes

(** Get single character string from byte value. *)
let of_byte byte = string_char byte

(** {1 Comparison} *)

(** Compare two strings lexicographically.
    Returns negative if [str1 < str2], 0 if equal, positive if [str1 > str2].
    Use [Ord.string_compare] for ordering type result. *)
let compare str1 str2 =
  if str1 < str2 then 0 - 1
  else if str1 > str2 then 1
  else 0

(** Test equality of two strings. *)
let equal str1 str2 = str1 == str2

(** {1 Iteration} *)

(** Apply [f] to each byte value. *)
let iter f str =
  let len = string_len str in
  for index = 1 to len do
    let _ = f (string_byte str index) in ()
  done

(** Apply [f] to each byte with its index (1-based). *)
let iteri f str =
  let len = string_len str in
  for index = 1 to len do
    let _ = f index (string_byte str index) in ()
  done

(** Fold over bytes from left to right. *)
let fold_left f init str =
  let len = string_len str in
  let acc = ref init in
  for index = 1 to len do
    acc := f !acc (string_byte str index)
  done;
  !acc

(** Return [true] if all bytes satisfy [predicate]. *)
let for_all predicate str =
  let len = string_len str in
  let result = ref true in
  let index = ref 1 in
  while !index <= len && !result do
    if not (predicate (string_byte str !index)) then
      result := false
    else
      index := !index + 1
  done;
  !result

(** Return [true] if any byte satisfies [predicate]. *)
let exists predicate str =
  let len = string_len str in
  let result = ref false in
  let index = ref 1 in
  while !index <= len && not !result do
    if predicate (string_byte str !index) then
      result := true
    else
      index := !index + 1
  done;
  !result
