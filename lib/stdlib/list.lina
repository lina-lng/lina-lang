(** List utilities for immutable linked lists.

    The list type is built-in: type 'a list = Nil | Cons of 'a * 'a list

    List syntax: [[]] for empty list, [[1; 2; 3]] for list literals,
    [x :: xs] for cons pattern matching. *)

(** {1 Construction} *)

(** The empty list. *)
let empty = Nil

(** Create a list with a single element. *)
let singleton x = Cons (x, Nil)

(** Prepend an element to a list. *)
let cons x xs = Cons (x, xs)

(** Create a list of integers from [start] to [stop] (inclusive).
    Returns empty list if [start > stop]. *)
let rec range start stop =
  if start > stop then Nil
  else Cons (start, range (start + 1) stop)

(** Create a list with [n] copies of [x].
    Returns empty list if [n <= 0].
    Named [replicate] instead of [repeat] to avoid Lua keyword conflict. *)
let rec replicate n x =
  if n <= 0 then Nil
  else Cons (x, replicate (n - 1) x)

(** Create a list of length [n] where element at index [i] is [f i].
    Returns empty list if [n <= 0]. *)
let init n f =
  let rec go i =
    if i >= n then Nil
    else Cons (f i, go (i + 1))
  in
  go 0

(** {1 Basic Operations} *)

(** Return the length of a list. O(n). *)
let length lst =
  let rec go acc xs = match xs with
    | Nil -> acc
    | Cons (_, rest) -> go (acc + 1) rest
  in
  go 0 lst

(** Return [true] if the list is empty. *)
let is_empty lst = match lst with
  | Nil -> true
  | Cons _ -> false

(** Return the first element, or [None] if empty. *)
let head lst = match lst with
  | Nil -> None
  | Cons (x, _) -> Some x

(** Return the list without its first element, or [None] if empty. *)
let tail lst = match lst with
  | Nil -> None
  | Cons (_, xs) -> Some xs

(** Return the last element, or [None] if empty. O(n). *)
let rec last lst = match lst with
  | Nil -> None
  | Cons (x, Nil) -> Some x
  | Cons (_, xs) -> last xs

(** Return the element at index [n], or [None] if out of bounds.
    Index is 0-based. O(n). *)
let rec nth n lst =
  if n < 0 then None
  else match lst with
    | Nil -> None
    | Cons (x, xs) ->
        if n == 0 then Some x
        else nth (n - 1) xs

(** {1 Transformations} *)

(** Apply [f] to each element, returning a new list. *)
let rec map f lst = match lst with
  | Nil -> Nil
  | Cons (x, xs) -> Cons (f x, map f xs)

(** Apply [f] to each element with its index. *)
let mapi f lst =
  let rec go i xs = match xs with
    | Nil -> Nil
    | Cons (x, rest) -> Cons (f i x, go (i + 1) rest)
  in
  go 0 lst

(** Keep only elements satisfying [predicate]. *)
let rec filter predicate lst = match lst with
  | Nil -> Nil
  | Cons (x, xs) ->
      if predicate x then Cons (x, filter predicate xs)
      else filter predicate xs

(** Apply [f] to each element and keep [Some] results. *)
let rec filter_map f lst = match lst with
  | Nil -> Nil
  | Cons (x, xs) -> match f x with
    | None -> filter_map f xs
    | Some y -> Cons (y, filter_map f xs)

(** Reverse a list. O(n). *)
let reverse lst =
  let rec go acc xs = match xs with
    | Nil -> acc
    | Cons (x, rest) -> go (Cons (x, acc)) rest
  in
  go Nil lst

(** Concatenate two lists. O(length of first list). *)
let rec append lst1 lst2 = match lst1 with
  | Nil -> lst2
  | Cons (x, xs) -> Cons (x, append xs lst2)

(** Concatenate a list of lists. *)
let rec concat lists = match lists with
  | Nil -> Nil
  | Cons (x, xs) -> append x (concat xs)

(** Map then flatten. [flat_map f lst] is [concat (map f lst)]. *)
let flat_map f lst = concat (map f lst)

(** {1 Folding} *)

(** Left fold: [fold_left f init [x1; x2; x3]] is [f (f (f init x1) x2) x3].
    Tail-recursive, prefer this for large lists. *)
let rec fold_left f acc lst = match lst with
  | Nil -> acc
  | Cons (x, xs) -> fold_left f (f acc x) xs

(** Right fold: [fold_right f [x1; x2; x3] init] is [f x1 (f x2 (f x3 init))].
    Not tail-recursive, may stack overflow on large lists. *)
let rec fold_right f lst acc = match lst with
  | Nil -> acc
  | Cons (x, xs) -> f x (fold_right f xs acc)

(** {1 Searching} *)

(** Find the first element satisfying [predicate], or [None]. *)
let rec find predicate lst = match lst with
  | Nil -> None
  | Cons (x, xs) ->
      if predicate x then Some x
      else find predicate xs

(** Find the index of the first element satisfying [predicate], or [None]. *)
let find_index predicate lst =
  let rec go i xs = match xs with
    | Nil -> None
    | Cons (x, rest) ->
        if predicate x then Some i
        else go (i + 1) rest
  in
  go 0 lst

(** Return [true] if any element satisfies [predicate]. *)
let rec exists predicate lst = match lst with
  | Nil -> false
  | Cons (x, xs) ->
      if predicate x then true
      else exists predicate xs

(** Return [true] if all elements satisfy [predicate]. *)
let rec for_all predicate lst = match lst with
  | Nil -> true
  | Cons (x, xs) ->
      if predicate x then for_all predicate xs
      else false

(** Return [true] if [element] is in the list. Uses [==] for comparison. *)
let rec mem element lst = match lst with
  | Nil -> false
  | Cons (x, xs) ->
      if x == element then true
      else mem element xs

(** {1 Sorting} *)

(** Split a list into two halves. *)
let split_half lst =
  let rec go slow fast = match fast with
    | Nil -> (Nil, slow)
    | Cons (_, Nil) -> (Nil, slow)
    | Cons (_, Cons (_, fast_rest)) -> match slow with
      | Nil -> (Nil, Nil)
      | Cons (y, slow_rest) ->
          let (left, right) = go slow_rest fast_rest in
          (Cons (y, left), right)
  in
  go lst lst

(** Merge two sorted lists using comparison function [cmp].
    [cmp a b] should return negative if [a < b], 0 if equal, positive if [a > b]. *)
let rec merge cmp lst1 lst2 = match (lst1, lst2) with
  | (Nil, ys) -> ys
  | (xs, Nil) -> xs
  | (Cons (x, xs), Cons (y, ys)) ->
      if cmp x y <= 0 then Cons (x, merge cmp xs lst2)
      else Cons (y, merge cmp lst1 ys)

(** Sort a list using comparison function [cmp]. Uses merge sort, O(n log n).
    [cmp a b] should return negative if [a < b], 0 if equal, positive if [a > b]. *)
let rec sort cmp lst = match lst with
  | Nil -> Nil
  | Cons (_, Nil) -> lst
  | _ ->
      let (left, right) = split_half lst in
      merge cmp (sort cmp left) (sort cmp right)

(** Sort a list by comparing keys extracted with [key_fn].
    Uses merge sort, O(n log n). *)
let sort_by key_fn lst =
  sort (fun a b ->
    let ka = key_fn a in
    let kb = key_fn b in
    if ka < kb then 0 - 1
    else if ka > kb then 1
    else 0
  ) lst

(** {1 Iteration} *)

(** Apply [f] to each element for side effects. *)
let rec iter f lst = match lst with
  | Nil -> ()
  | Cons (x, xs) ->
      let _ = f x in
      iter f xs

(** Apply [f] to each element with its index for side effects. *)
let iteri f lst =
  let rec go i xs = match xs with
    | Nil -> ()
    | Cons (x, rest) ->
        let _ = f i x in
        go (i + 1) rest
  in
  go 0 lst

(** {1 Zipping} *)

(** Combine two lists into a list of pairs.
    Stops at the shorter list. *)
let rec zip lst1 lst2 = match (lst1, lst2) with
  | (Nil, _) -> Nil
  | (_, Nil) -> Nil
  | (Cons (x, xs), Cons (y, ys)) -> Cons ((x, y), zip xs ys)

(** Split a list of pairs into two lists. *)
let unzip lst =
  let rec go acc1 acc2 xs = match xs with
    | Nil -> (reverse acc1, reverse acc2)
    | Cons ((a, b), rest) -> go (Cons (a, acc1)) (Cons (b, acc2)) rest
  in
  go Nil Nil lst

(** {1 Comparison} *)

(** Return [true] if lists are equal using [eq_fn] for element comparison. *)
let rec equal eq_fn lst1 lst2 = match (lst1, lst2) with
  | (Nil, Nil) -> true
  | (Cons (x, xs), Cons (y, ys)) ->
      if eq_fn x y then equal eq_fn xs ys
      else false
  | _ -> false

(** Compare two lists lexicographically using [cmp_fn].
    Returns negative if [lst1 < lst2], 0 if equal, positive if [lst1 > lst2]. *)
let rec compare cmp_fn lst1 lst2 = match (lst1, lst2) with
  | (Nil, Nil) -> 0
  | (Nil, Cons _) -> 0 - 1
  | (Cons _, Nil) -> 1
  | (Cons (x, xs), Cons (y, ys)) ->
      let c = cmp_fn x y in
      if c != 0 then c
      else compare cmp_fn xs ys

(** {1 Additional Utilities} *)

(** Take the first [n] elements. Returns fewer if list is shorter. *)
let rec take n lst =
  if n <= 0 then Nil
  else match lst with
    | Nil -> Nil
    | Cons (x, xs) -> Cons (x, take (n - 1) xs)

(** Drop the first [n] elements. Returns empty if list is shorter. *)
let rec drop n lst =
  if n <= 0 then lst
  else match lst with
    | Nil -> Nil
    | Cons (_, xs) -> drop (n - 1) xs

(** Split at index [n]: [(take n lst, drop n lst)]. *)
let split_at n lst = (take n lst, drop n lst)

(** Partition a list into elements that satisfy [predicate] and those that don't. *)
let partition predicate lst =
  let rec go yes no xs = match xs with
    | Nil -> (reverse yes, reverse no)
    | Cons (x, rest) ->
        if predicate x then go (Cons (x, yes)) no rest
        else go yes (Cons (x, no)) rest
  in
  go Nil Nil lst

(** Insert [separator] between each element. *)
let intersperse separator lst = match lst with
  | Nil -> Nil
  | Cons (x, xs) ->
      let rec go ys = match ys with
        | Nil -> Nil
        | Cons (y, rest) -> Cons (separator, Cons (y, go rest))
      in
      Cons (x, go xs)

(** {1 Array Conversion} *)

(** [to_array lst] converts list to array. O(n). *)
let to_array lst = Array.of_list lst

(** [of_array arr] converts array to list. O(n). *)
let of_array arr = Array.to_list arr
